/*
VERGE 2.5+j (AKA V2k+j) -  A video game creation engine
Copyright (C) 1998-2000  Benjamin Eirich (AKA vecna), et al
Please see authors.txt for a complete list of contributing authors.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

// verge.c
// Copyright (C) 1998 Benjamin Eirich

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// CHANGELOG:
// <aen, apr 21>
// + changed Log() & Logp() to take variable args.
// + altered translucency lookup code a bit
// + cleaned up USER.CFG parsing
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

int hicolor=0;

#include <stdarg.h> // va_*

#include "verge.h"

static unsigned char vergepal[]=
{
	0x00,0x00,0x00,0x02,0x02,0x02,0x03,0x03,0x03,0x05,0x05,0x05,0x07,
	0x07,0x07,0x09,0x09,0x09,0x0a,0x0a,0x0a,0x0c,0x0c,0x0c,0x0e,0x0e,
	0x0e,0x0f,0x0f,0x0f,0x11,0x11,0x11,0x13,0x13,0x13,0x15,0x15,0x15,
	0x16,0x16,0x16,0x18,0x18,0x18,0x1a,0x1a,0x1a,0x1c,0x1c,0x1c,0x1d,
	0x1d,0x1d,0x1f,0x1f,0x1f,0x21,0x21,0x21,0x22,0x22,0x22,0x24,0x24,
	0x24,0x26,0x26,0x26,0x28,0x28,0x28,0x29,0x29,0x29,0x2b,0x2b,0x2b,
	0x2e,0x2e,0x2e,0x31,0x31,0x31,0x34,0x34,0x34,0x36,0x36,0x36,0x39,
	0x39,0x39,0x3c,0x3c,0x3c,0x3f,0x00,0x00,0x3b,0x00,0x00,0x38,0x00,
	0x00,0x35,0x00,0x00,0x32,0x00,0x00,0x2f,0x00,0x00,0x2c,0x00,0x00,
	0x29,0x00,0x00,0x26,0x00,0x00,0x22,0x00,0x00,0x1f,0x00,0x00,0x1c,
	0x00,0x00,0x19,0x00,0x00,0x16,0x00,0x00,0x13,0x00,0x00,0x10,0x00,
	0x00,0x3f,0x36,0x36,0x3f,0x2e,0x2e,0x3f,0x27,0x27,0x3f,0x1f,0x1f,
	0x3f,0x17,0x17,0x3f,0x10,0x10,0x3f,0x08,0x08,0x3f,0x00,0x00,0x11,
	0x0b,0x06,0x13,0x0d,0x07,0x15,0x0f,0x09,0x17,0x11,0x0a,0x18,0x13,
	0x0b,0x1a,0x15,0x0c,0x1c,0x17,0x0e,0x1e,0x19,0x0f,0x3f,0x3f,0x36,
	0x3f,0x3f,0x2e,0x3f,0x3f,0x27,0x3f,0x3f,0x1f,0x3f,0x3e,0x17,0x3f,
	0x3d,0x10,0x3f,0x3d,0x08,0x3f,0x3d,0x00,0x39,0x36,0x00,0x33,0x31,
	0x00,0x2d,0x2b,0x00,0x27,0x27,0x00,0x21,0x21,0x00,0x1c,0x1b,0x00,
	0x16,0x15,0x00,0x10,0x10,0x00,0x34,0x3f,0x17,0x31,0x3f,0x10,0x2d,
	0x3f,0x08,0x28,0x3f,0x00,0x24,0x39,0x00,0x20,0x33,0x00,0x1d,0x2d,
	0x00,0x18,0x27,0x00,0x36,0x3f,0x36,0x2e,0x3d,0x2e,0x27,0x3b,0x27,
	0x1f,0x39,0x1f,0x17,0x36,0x17,0x0f,0x34,0x0f,0x08,0x32,0x08,0x00,
	0x30,0x00,0x00,0x2d,0x00,0x00,0x2b,0x00,0x00,0x28,0x00,0x00,0x26,
	0x00,0x00,0x23,0x00,0x00,0x21,0x00,0x00,0x1e,0x00,0x00,0x1c,0x00,
	0x00,0x19,0x00,0x00,0x17,0x00,0x00,0x14,0x00,0x00,0x12,0x00,0x00,
	0x0f,0x00,0x02,0x0d,0x02,0x03,0x0a,0x03,0x05,0x08,0x05,0x36,0x3f,
	0x3f,0x2e,0x3f,0x3f,0x27,0x3f,0x3f,0x1f,0x3f,0x3f,0x17,0x3f,0x3f,
	0x0f,0x3f,0x3f,0x08,0x3f,0x3f,0x00,0x3f,0x3f,0x00,0x39,0x39,0x00,
	0x33,0x33,0x00,0x2d,0x2d,0x00,0x27,0x27,0x00,0x22,0x22,0x00,0x1c,
	0x1c,0x00,0x16,0x16,0x00,0x10,0x10,0x17,0x2f,0x3f,0x10,0x2c,0x3f,
	0x08,0x2a,0x3f,0x00,0x27,0x3f,0x00,0x23,0x39,0x00,0x1f,0x33,0x00,
	0x1b,0x2d,0x00,0x17,0x27,0x36,0x36,0x3f,0x2e,0x2f,0x3f,0x27,0x27,
	0x3f,0x1f,0x20,0x3f,0x17,0x18,0x3f,0x10,0x10,0x3f,0x08,0x09,0x3f,
	0x00,0x01,0x3f,0x00,0x00,0x3f,0x00,0x00,0x3b,0x00,0x00,0x38,0x00,
	0x00,0x35,0x00,0x00,0x32,0x00,0x00,0x2f,0x00,0x00,0x2c,0x00,0x00,
	0x29,0x00,0x00,0x26,0x00,0x00,0x22,0x00,0x00,0x1f,0x00,0x00,0x1c,
	0x00,0x00,0x19,0x00,0x00,0x16,0x00,0x00,0x13,0x00,0x00,0x10,0x0d,
	0x08,0x00,0x0f,0x09,0x00,0x12,0x0a,0x00,0x14,0x0b,0x00,0x16,0x0c,
	0x00,0x19,0x0d,0x00,0x1b,0x0e,0x00,0x1e,0x0f,0x00,0x20,0x10,0x00,
	0x22,0x11,0x00,0x25,0x12,0x00,0x28,0x15,0x03,0x2c,0x18,0x06,0x2f,
	0x1b,0x09,0x32,0x1e,0x0c,0x35,0x21,0x0e,0x39,0x24,0x11,0x3c,0x27,
	0x14,0x3f,0x2a,0x17,0x3f,0x2e,0x1c,0x3f,0x31,0x22,0x3f,0x35,0x27,
	0x3f,0x38,0x2c,0x22,0x1c,0x12,0x25,0x1f,0x14,0x29,0x22,0x17,0x2c,
	0x25,0x19,0x2f,0x28,0x1c,0x32,0x2a,0x1e,0x36,0x2d,0x20,0x39,0x30,
	0x23,0x3c,0x33,0x25,0x3f,0x3a,0x37,0x3f,0x38,0x34,0x3f,0x36,0x31,
	0x3f,0x35,0x2f,0x3f,0x33,0x2c,0x3f,0x31,0x29,0x3f,0x2f,0x27,0x3f,
	0x2e,0x24,0x3f,0x2c,0x20,0x3f,0x29,0x1c,0x3f,0x27,0x18,0x3c,0x25,
	0x17,0x3a,0x23,0x16,0x37,0x22,0x15,0x34,0x20,0x14,0x32,0x1f,0x13,
	0x2f,0x1e,0x12,0x2d,0x1c,0x11,0x2a,0x1a,0x10,0x28,0x19,0x0f,0x27,
	0x18,0x0e,0x24,0x17,0x0d,0x22,0x16,0x0c,0x20,0x14,0x0b,0x1d,0x13,
	0x0a,0x1b,0x12,0x09,0x17,0x10,0x08,0x15,0x0f,0x07,0x12,0x0e,0x06,
	0x10,0x0c,0x06,0x0e,0x0b,0x05,0x0a,0x08,0x03,0x3f,0x00,0x00,0x3f,
	0x04,0x00,0x3f,0x08,0x00,0x3f,0x0d,0x00,0x3f,0x11,0x00,0x3f,0x15,
	0x00,0x3f,0x19,0x00,0x3f,0x1d,0x00,0x3f,0x22,0x00,0x3f,0x26,0x00,
	0x3f,0x2a,0x00,0x3f,0x2e,0x00,0x3f,0x32,0x00,0x3f,0x37,0x00,0x3f,
	0x3b,0x00,0x3f,0x3f,0x00,0x3f,0x2f,0x00,0x36,0x28,0x00,0x2d,0x22,
	0x00,0x24,0x1b,0x00,0x1b,0x14,0x00,0x12,0x0d,0x00,0x09,0x07,0x00,
	0x00,0x00,0x00,0x29,0x00,0x28,0x23,0x00,0x2b,0x1d,0x00,0x2f,0x17,
	0x00,0x32,0x12,0x00,0x35,0x0c,0x00,0x38,0x06,0x00,0x3c,0x3f,0x3f,
	0x3f,0x3f
};


// ================================= Data ====================================

// declared in VDRIVER.C
extern byte* translucency_table;

char*	strbuf		=0;		// Universal temporary string buffer. :)

char	joyflag		=0;

int		vidxres		=0;
int		vidyres		=0;		// Joystick on/off | Video mode to use

char	logoutput	=0;		// Verbose debugging startup mode

char	nocdaudio	=0;		// do not use CD audio

string_t	startmap	="";	// startup map

// ================================= Code ====================================

void InitializeDefaults()
{
// default keyboard controls
	kb1=K_ENTER;
	kb2=K_ALT;
	kb3=K_ESC;
	kb4=' ';

// default joystick controls
	jb1=1;
	jb2=2;
	jb3=3;
	jb4=4;
// joystick defaults to disabled
	joyflag=0;

// default res is mode $13
	vidxres=320;
	vidyres=200;

// Don't be annoyingly verbose
	logoutput=0;

// clear this here so we don't trigger random events on the first keypress
	V_memset(bindarray, 0, sizeof(bindarray));

// globally used string; TODO: remove all dependencies on this, and get rid of it
	strbuf=(char *) valloc(2000, "strbuf", OID_TEMP);

// default startup map
	startmap=""; //test.map";

// default MikMod settings
	md_mode		=DMODE_STEREO|DMODE_16BITS|DMODE_INTERP;
	md_mixfreq	=22050;

// prep the joystick for use
	Calibrate();
}

// <aen, apr 21>
// + added these few static routines and made ParseStartupFiles() use'em

static VFILE *user_cfg_file=0;
static char parse_str[256];

static char *parse_cfg_token()
  { vscanf(user_cfg_file, "%s", parse_str); return parse_str; }

// compares string against parse_str (grabbed by parse_cfg_token())
// 0=mismatch, 1=match
static int parse_match(char *str)
  { return !strcmp(parse_str, str); }

// zero error correcting or detection; fix <aen, apr 21>
void ParseStartupFiles()
{
  user_cfg_file = vopen("user.cfg");
  if (!user_cfg_file)
  {
    return;
  }

  while (1)
  {
    parse_cfg_token();

    // mounts a pack file; up to 3? (perhaps gaurd against more?)
    if (parse_match("mount"))
      { MountVFile(parse_cfg_token()); continue; }
    // set video resolution
    else if (parse_match("vidmode"))
    {
      vidxres = V_atoi(parse_cfg_token());
      vidyres = V_atoi(parse_cfg_token());

      // check validity
      if (vidxres != 256 && vidxres != 320
      &&  vidxres != 360 && vidxres != 640)
      {
        Log(va("user.cfg: invalid resolution width %i passed to vidmode", vidxres));
      }
      if (vidyres != 200 && vidyres != 240
      &&  vidyres != 256 && vidyres != 480)
      {
        Log(va("user.cfg: invalid resolution height %i passed to vidmode", vidyres));
      }

      continue;
    }
    // log to VERGE.LOG
    else if (parse_match("log"))
      { logoutput=1; continue; }
    // disable CD playing
    else if (parse_match("nocdaudio"))
      { nocdaudio=1; continue; }
    // map VERGE.EXE will run first when executed
    else if (parse_match("startmap"))
      { parse_cfg_token(); continue; } //V_strcpy(startmap, parse_cfg_token());     continue; }
    // 0=auto detect, 1=???, 2=???, 3=nosound
    else if (parse_match("sound_device"))
    {
    	md_device = (UWORD)V_atoi(parse_cfg_token());
    	continue;
    }
    // sound lib setting
    else if (parse_match("mixrate"))
    {
    	md_mixfreq = (UWORD)V_atoi(parse_cfg_token());
    	continue;
    }
    // sound lib setting
    else if (parse_match("dmabufsize"))
    {
    	md_dmabufsize = (UWORD)V_atoi(parse_cfg_token());
    	continue;
   	}
    // sound lib setting
    else if (parse_match("force8bit"))
      { continue; }
    // sound lib setting
    else if (parse_match("forcemono"))
      { continue; }
	else if (parse_match("hicolor"))
	{
		hicolor=1;
		continue;
	}

    // unknown command, assume end
    break;
  }

  // done parsing config
  vclose(user_cfg_file);
}

void ParseAutoCFG()
{
	VFILE*	vf;
	int i;

	vf	=vopen("auto.cfg");
	if (!vf) return;

	while (1)
	{
		char temp[256+1]={0};
		vgets(temp, 256, vf);
		temp[256]='\0';

		for (i=0; i<V_strlen(temp); i++) {
			if (temp[i]==10 || temp[i]==13)
				temp[i]=0;
		}
		if (V_strlen(temp)<2) {
			break;
		}
		//cmd=temp;
		Console_SendCommand(temp);
	}
	vclose(vf);
}

void InitLog()
{
  if (logoutput)
  {
    remove("verge.log");
  }
}

static FILE* Log_OpenLog()
{
	FILE*	f;

	f=fopen("VERGE.LOG", "aw");
	if (!f)
		Sys_Error("Log_OpenLog: unable to open VERGE.LOG");

	return	f;
}

void Log(const char* message)
{
	FILE*	f;

	if (!logoutput)
		return;

	f=Log_OpenLog();

	fprintf(f, "%s\n", message);
	fflush(f);

	fclose(f);
}

// used in conjunction with LogDone()
void Logp(const char* message)
{
	FILE*	f;

	if (!logoutput)
		return;

	f=Log_OpenLog();

	fprintf(f, "%s", message);
	fflush(f);

	fclose(f);
}

void LogDone()
{
	FILE*	f;

	if (!logoutput)
		return;

	f=Log_OpenLog();

	fprintf(f, "... OK\n");
	fflush(f);

	fclose(f);
}

void InitSystems()
{
	InitLog();
	Log("V2 startup. Logfile initialized.");

	Logp("Sys: Initializing keyboard handler.");
	InitKeyboard();
	LogDone();
#ifdef __DJGPP__
	keyboard_chain(0);
#endif

	Logp("Sys: Initializing timer. Set 100hz.");
	InitTimer();
	LogDone();

	/*
	Logp("Sys: Initializing CD Audio.");
	CD_Init();
	LogDone();
	*/

	Logp("Sys: Initializing music system.");
	InitMusicSystem();
	LogDone();

	GFX_SetMode(vidxres, vidyres);
	GFX_SetPalette(vergepal);
}

void LoadTransTable()
{
	VFILE*	vf;

	if (translucency_table)
		Sys_Error("Foul things are afoot.");

	vf = vopen("TRANS.TBL");
	if (!vf)
	{
		return;
	}

	translucency_table = (byte *) valloc(256*256, "translucency_table", OID_MISC);

	vread(translucency_table, 256*256, vf);
	vclose(vf);
}

void vmain(int argc, char *argv[])
{
	InitializeDefaults();
	ParseStartupFiles();

	InitSystems();

	if (2 == argc)
	{
		startmap = argv[1];
	}

	memcpy(game_palette, vergepal, 3*256);
	Console_Init();

	Console_Printf(va("VERGE System Version %s", VERSION));
	Console_Printf("Copyright (C)1998 vecna");
	Console_Printf("");

	ParseAutoCFG();

	LoadTransTable();

	LoadSystemVC();
// startmap override?
	if (startmap.length())
    	LoadMAP((const char*)startmap);
	else
		RunSystemAutoexec();

// if there is no starting map at this point, we're done.
	if (startmap.length() < 1)
		Sys_Error("");

// don't forget to set input destination
	key_dest = key_game;

	while (1)
	{
		while (timer_count > 0)
		{
			timer_count -= 1;
			GameTick();
		}

		if (kill)
		{
			FreeVSP();
			FreeMAP();
			FreeCHRList();
			vcsp = vcstack;
			kill = 0;
			LoadMAP((const char*)startmap);
		}

		Render();
		ShowPage();
	}
}